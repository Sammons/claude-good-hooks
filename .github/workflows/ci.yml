# ===================================================================
# Continuous Integration (CI) Workflow
# ===================================================================
# 
# This workflow runs comprehensive tests and validation on every push 
# to main and pull request. It ensures code quality, runs tests,
# validates package structure, and generates coverage reports.
#
# Triggers:
# - Push to main branch
# - Pull requests targeting main branch
#
# Jobs:
# 1. test: Run tests, linting, formatting checks, and coverage
# 2. validate-packages: Validate package structure and simulate publishing
#
# The workflow uses concurrency control to cancel previous runs when 
# new commits are pushed to the same branch/PR.
# ===================================================================

name: CI

on:
  # Trigger on pushes to main branch to validate changes going to production
  push:
    branches: [main]
  # Trigger on pull requests to main to validate changes before merging
  pull_request:
    branches: [main]

# Concurrency control: Cancel previous runs for the same workflow + ref
# This saves CI resources by stopping outdated runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===================================================================
  # Primary Test Job
  # ===================================================================
  # Runs the core validation pipeline including tests, linting, 
  # formatting checks, builds, and coverage reporting.
  # ===================================================================
  test:
    name: Test & Build
    runs-on: ubuntu-latest # Use latest Ubuntu runner for consistency
    
    steps:
      # Step 1: Get the source code
      # Uses v4 for latest features and security updates
      - name: Checkout
        uses: actions/checkout@v4
        
      # Step 2: Setup Node.js environment
      # Pin to Node.js 20.x for consistency with development environment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          
      # Step 3: Setup pnpm package manager
      # Pin to specific version for reproducible builds
      # run_install: false to control installation timing
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.12.4 # Pinned version for consistency
          run_install: false # We'll install manually to use caching
          
      # Step 4: Get pnpm store location for caching
      # This step determines where pnpm stores packages for cache optimization
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
          
      # Step 5: Cache pnpm store for faster builds
      # Cache key includes pnpm-lock.yaml hash to invalidate when dependencies change
      # Fallback to previous cache if exact match not found
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
            
      # Step 6: Install dependencies
      # --frozen-lockfile ensures we use exact versions from lockfile
      # Fails if lockfile is out of sync with package.json
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      # Step 7: Code quality checks
      # Verify code is properly formatted according to project standards
      - name: Check formatting
        run: pnpm check-format
        
      # Step 8: Run ESLint checks
      # Catch potential bugs and enforce coding standards
      - name: Run linting
        run: pnpm lint
        
      # Step 9: Run test suite
      # Execute all unit and integration tests
      - name: Run tests
        run: pnpm test
        
      # Step 10: Validate package dependencies
      # Check for circular dependencies and architectural violations
      - name: Validate dependencies
        run: |
          echo "🔍 Validating package dependencies..."
          
          # Install madge for circular dependency detection
          npm install -g madge
          
          # Check for circular dependencies
          echo "Checking for circular dependencies..."
          if madge --circular packages/*/src --extensions ts; then
            echo "✅ No circular dependencies found"
          else
            echo "❌ Circular dependencies detected"
            exit 1
          fi
          
          # Validate peer dependencies are declared
          echo "Validating peer dependency declarations..."
          
          # Check that packages using types declare it as peer dependency
          for pkg in packages/*/; do
            if [ -f "$pkg/package.json" ]; then
              pkg_name=$(basename "$pkg")
              echo "Checking $pkg_name..."
              
              # Check if package uses @sammons/claude-good-hooks-types
              if grep -r "from ['\"]@sammons/claude-good-hooks-types" "$pkg/src" 2>/dev/null; then
                # Verify it's declared as peer dependency (except for types package itself)
                if [ "$pkg_name" != "claude-good-hooks-types" ]; then
                  if ! grep -q '"@sammons/claude-good-hooks-types"' "$pkg/package.json" | grep -A5 -B5 '"peerDependencies"'; then
                    echo "⚠️ Warning: $pkg_name uses types but doesn't declare it as peer dependency"
                  fi
                fi
              fi
              
              # Check if package uses factories
              if grep -r "from ['\"]@sammons/claude-good-hooks-factories" "$pkg/src" 2>/dev/null; then
                if [ "$pkg_name" != "claude-good-hooks-factories" ]; then
                  if ! grep -q '"@sammons/claude-good-hooks-factories"' "$pkg/package.json" | grep -A5 -B5 '"peerDependencies"'; then
                    echo "⚠️ Warning: $pkg_name uses factories but doesn't declare it as peer dependency"
                  fi
                fi
              fi
            fi
          done
          
          echo "✅ Dependency validation completed"

      # Step 11: Build all packages
      # Verify that all packages can be built successfully
      # This catches TypeScript compilation errors and build issues
      - name: Build all packages
        run: pnpm build
        
      # Step 12: Generate test coverage report
      # continue-on-error: true means workflow continues even if coverage fails
      # This prevents flaky coverage tools from breaking the build
      - name: Generate coverage report
        run: pnpm test:coverage
        continue-on-error: true
        
      # Step 13: Generate coverage artifacts for local badge generation  
      # Coverage data will be used by the coverage workflow for badge generation
      - name: Store coverage for badge generation
        run: |
          echo "📊 Storing coverage data for badge generation..."
          
          # Create coverage artifact directory
          mkdir -p .github/artifacts
          
          # Copy coverage summary if it exists
          if [ -f "coverage/coverage-summary.json" ]; then
            cp coverage/coverage-summary.json .github/artifacts/
            echo "✅ Coverage summary stored for badge generation"
          else
            echo "⚠️ No coverage summary found to store"
          fi

  # ===================================================================
  # Package Validation Job
  # ===================================================================
  # This job validates that packages are structured correctly and ready
  # for publishing. It runs after the test job completes successfully.
  # 
  # Purpose: Simulate publishing to catch packaging issues before release
  # Dependency: Requires the 'test' job to complete successfully
  # ===================================================================
  validate-packages:
    name: Validate Package Structure
    runs-on: ubuntu-latest
    needs: test # Only run if tests pass - saves resources on test failures
    
    steps:
      # Step 1: Get the source code (same as test job)
      - name: Checkout
        uses: actions/checkout@v4
        
      # Step 2: Setup Node.js (consistent with test job)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          
      # Step 3: Setup pnpm (same configuration as test job)
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.12.4
          run_install: false
          
      # Step 4: Get pnpm store directory for caching
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
          
      # Step 5: Reuse cache from test job
      # Same cache key ensures we reuse downloaded dependencies
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
            
      # Step 6: Install dependencies (should be fast due to caching)
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      # Step 7: Build packages to ensure they're ready for validation
      - name: Build packages
        run: pnpm build
        
      # Step 8: Validate package structure and contents
      # This simulates what would be published to NPM without actually publishing
      # Helps catch missing files, incorrect package.json configs, etc.
      - name: Check package contents
        run: |
          echo "Validating package structure for publishable packages..."
          echo "This simulates 'npm publish --dry-run' to catch packaging issues"
          
          # Loop through all package directories
          for pkg in packages/*/; do
            # Only check packages that aren't marked as private
            if [ -f "$pkg/package.json" ] && [ "$(cat "$pkg/package.json" | grep -c '"private".*true')" -eq 0 ]; then
              echo "📦 Checking package: $pkg"
              cd "$pkg"
              
              # Run npm pack --dry-run to simulate publishing
              # This shows what files would be included and catches common issues
              if [ -f "package.json" ]; then
                npm pack --dry-run
              fi
              cd - > /dev/null
            else
              echo "⏭️  Skipping private package: $pkg"
            fi
          done
          
          echo "✅ Package validation completed"

  # ===================================================================
  # Smoke Tests Job
  # ===================================================================
  # Runs end-to-end smoke tests in a Docker environment to validate
  # the CLI functionality in an isolated container, preventing any
  # side effects on the CI runner.
  # ===================================================================
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [test] # Wait for basic tests to pass before running smoke tests
    
    steps:
      # Step 1: Get the source code
      - name: Checkout repository
        uses: actions/checkout@v4
        
      # Step 2: Setup pnpm
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest
          
      # Step 3: Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
          
      # Step 4: Install dependencies
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      # Step 5: Build CLI package (required for smoke tests)
      - name: Build CLI package
        run: |
          echo "🔨 Building CLI package for smoke tests..."
          cd packages/claude-good-hooks-cli
          pnpm build
          cd ../..
        
      # Step 6: Setup Docker Buildx for advanced Docker features
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      # Step 7: Build smoke test Docker image
      - name: Build smoke test image
        run: |
          echo "🐳 Building smoke test Docker image..."
          cd packages/claude-good-hooks-smoke-tests
          docker build -t claude-good-hooks-smoke-tests -f Dockerfile ../../
          
      # Step 8: Run smoke tests in Docker container
      - name: Run smoke tests
        run: |
          echo "🧪 Running smoke tests in Docker container..."
          cd packages/claude-good-hooks-smoke-tests
          
          # Start container in background
          docker run -d \
            --name claude-good-hooks-smoke-tests \
            -v "$(pwd)/../../packages/claude-good-hooks-types:/app/packages/claude-good-hooks-types" \
            -v "$(pwd)/../../packages/claude-good-hooks-cli:/app/packages/claude-good-hooks-cli" \
            -v "$(pwd):/app/packages/claude-good-hooks-smoke-tests" \
            -v "$(pwd)/../../package.json:/app/package.json" \
            -v "$(pwd)/../../pnpm-workspace.yaml:/app/pnpm-workspace.yaml" \
            -v "$(pwd)/../../pnpm-lock.yaml:/app/pnpm-lock.yaml" \
            -w /app/packages/claude-good-hooks-smoke-tests \
            -e NODE_ENV=test \
            -e CI=true \
            claude-good-hooks-smoke-tests \
            tail -f /dev/null
            
          # Wait for container to be ready
          sleep 3
          
          # Install dependencies in container
          docker exec claude-good-hooks-smoke-tests pnpm install
          
          # Run the smoke tests
          docker exec claude-good-hooks-smoke-tests pnpm run _smoke:internal
          
      # Step 9: Cleanup (always runs even if tests fail)
      - name: Cleanup Docker resources
        if: always()
        run: |
          echo "🧹 Cleaning up Docker resources..."
          docker stop claude-good-hooks-smoke-tests 2>/dev/null || true
          docker rm claude-good-hooks-smoke-tests 2>/dev/null || true
          docker rmi claude-good-hooks-smoke-tests 2>/dev/null || true